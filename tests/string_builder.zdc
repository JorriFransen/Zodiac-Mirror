
_c :: import c;
using _c;

String_Builder :: struct
{
    first_block        : *_String_Builder_Block;
    current_block      : *_String_Builder_Block;
    initial_block_size : u64;
}

_String_Builder_Block :: struct
{
    data       : *u8;
    size       : u64;
    used_size  : u64;
    next_block : *_String_Builder_Block;
}

init :: (sb: *String_Builder, initial_block_size: u64)
{
    sb.initial_block_size = initial_block_size;
    sb.first_block = create_block(initial_block_size);
    sb.current_block = sb.first_block;
}

create_block :: (block_size: u64) -> *_String_Builder_Block
{
    result := (:*_String_Builder_Block)malloc(sizeof(_String_Builder_Block));

    result.data = malloc(block_size);
    result.size = block_size;
    result.used_size = 0;
    result.next_block = null;

    return result;
}

append :: (sb: *String_Builder, str: *u8)
{
    length := strlen(str);
    block := sb.current_block;

    if (block.used_size + length < block.size)
    {
        append_to_block(block, str, length);
    }
    else
    {
        block_size := sb.initial_block_size;
        if (length > block_size)
        {
            block_size = length + 1;
        }
        block.next_block = create_block(sb.initial_block_size);
        sb.current_block = block.next_block;
        append_to_block(block.next_block, str, length);
    }
}

append :: (sb: *String_Builder, number: u64)
{
    _buf: [32]u8;
    buf := *_buf[0];
    sprintf(buf, "%lu", number);
    append(sb, buf);
}

append_to_block :: (sb: *_String_Builder_Block, str: *u8, length: u64) -> bool
{
    if (sb.used_size + length < sb.size)
    {
        sbi := sb.used_size;
        for (i: u64 = 0; i < length; i = i + 1)
        {
            sb.data[sbi] = str[i];
            sbi = sbi + 1;
        }

        sb.used_size = sb.used_size + length;

        return true;
    }
    else
    {
        return false;
    }
}

copy_to_string :: (sb: *String_Builder) -> *u8
{
    total_size: u64 = 1;

    block := sb.first_block;
    while (block)
    {
        total_size = total_size + block.used_size;
        block = block.next_block;
    }

    // printf("total_size: %d\n", total_size);

    result := (:*u8)malloc(total_size);
    ri: u64 = 0;
    block = sb.first_block;
    while (block)
    {
        for (i: u64 = 0; i < block.used_size; i = i + 1)
        {
            result[ri] = block.data[i];
            ri = ri + 1;
        }
        block = block.next_block;
    }

    result[ri] = 0;

    return result;
}

free :: (sb: *String_Builder)
{
    block := sb.first_block;
    while (block)
    {
        next := block.next_block;

        free(block.data);
        free(block);

        block = next;
    }

    sb.first_block = null;
}
