
_c :: import c;

String :: struct
{
    data   : *u8;
    length : u64;
}

string_length :: (c_str: *u8) -> u64
{
    length : u64 = 0;
    i : u64 = 0;

    while (c_str[i] != 0)
    {
        i = i + 1;
        length = length + 1;
    }

    return length;
}

print :: (str: String)
{
    _c.printf("%.*s\n", str.length, str.data);
}

print :: (num: u64)
{
    _buf: [32]u8;
    buf := *_buf[0];
    length := _c.sprintf(buf, "%llu", num);
    print({ buf, (:u64)length });
}

Array :: struct(T)
{
    data     : *T;
    count    : u64;
    capacity : u64;

    #overload_index array_index;
}

array_add :: (array: *Array($T), element: T)
{
    assert(array);

    if (array.count >= array.capacity)
    {
        new_cap := array.capacity * 2;
        if (new_cap < 8) new_cap = 8;
        array_grow(array, new_cap);
    }

    assert(array.data);

    array.data[array.count] = element;
    array.count = array.count + 1;
}

array_index :: (array: Array($T), index: u64) -> T
{
    if (index < array.count)
    {
        return array.data[index];
    }

    assert(false);
}

array_grow :: (array: *Array($T), new_cap: u64)
{
    assert(array);
    assert(new_cap > array.capacity);

    new_data := _c.malloc(sizeof(T) * new_cap);
    assert(new_data);

    if (array.data)
    {
        assert(array.capacity);
        _c.memcpy(new_data, array.data, array.capacity * sizeof(T));
        _c.free(array.data);
    }
    else
    {
        assert(array.capacity == 0);
        assert(array.count == 0);
    }

    array.data = new_data;
    array.capacity = new_cap;
}

array_free :: (array: *Array($T))
{
    assert(array);
    if (array.data)
    {
        _c.free(array.data);
        array.data = null;
        array.count = 0;
        array.capacity = 0;
    }
}
