
_c :: import c;

String :: struct
{
    data   : *u8;
    length : u64;
}

string_length :: (c_str: *u8) -> u64
{
    length : u64 = 0;
    i : u64 = 0;

    while (c_str[i] != 0)
    {
        i = i + 1;
        length = length + 1;
    }

    return length;
}

print :: (str: String)
{
    _c.printf("%.*s\n", str.length, str.data);
}

print :: (num: u64)
{
    _buf: [32]u8;
    buf := *_buf[0];
    length := _c.sprintf(buf, "%llu", num);
    print({ buf, (:u64)length });
}

Array :: struct(T)
{
    data     : *T;
    count    : u64;
    capacity : u64;
}

// array_init :: (array: *Array($T), initial_capacity: u64)
// {
//     array.data = _c.malloc(sizeof(T)  * initial_capacity);
//     array.count = 0;
//     array.capacity = initial_capacity;
// }

array_add :: (array: *Array($T), element: T)
{
    if (array.count >= array.capacity)
    {
        new_cap := array.capacity * 2;
        if (new_cap < 8) new_cap = (:u64)8;
        array_grow(array, new_cap);
    }

    array.data[array.count] = element;
    array.count = array.count + 1;
}

array_grow :: (array: *Array($T), new_cap: u64)
{
    new_data := _c.malloc(sizeof(T) * new_cap);
    if (array.data)
    {
        _c.memcpy(new_data, array.data, array.capacity * sizeof(T));
        _c.free(array.data);
    }
    array.data = new_data;
    array.capacity = new_cap;

}
