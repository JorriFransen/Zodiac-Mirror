
_c :: import c;

is_power_of_two :: (x: u64) -> bool
{
    return (x & (x - 1)) == 0;
}

align_forward :: (ptr: *u64, align: u64) -> *u64
{
    p: *u64;
    a: *u64;
    modulo: *u64;

    assert(is_power_of_two(align));

    p = ptr;
    a = (:*u64)align;
    modulo = p & (a - 1);

    if (modulo != 0)
    {
        p += a - modulo;
    }

    return p;
}

Arena :: struct
{
    buf             : *u8;
    buf_length      : u64;
    previous_offset : u64;
    current_offset  : u64;
}

arena_init :: (arena: *Arena, buffer: *void, buffer_length: u64)
{
    arena.buf = (:u8)buffer;
    arena.buf_length = buffer_length;
    arena.previous_offset = 0;
    arena.current_offset = 0;
}

arena_free :: (arena: *Arena) {}

Temp_Arena_Memory :: struct
{
    arena           : *Arena;
    previous_offset : u64;
    current_offset  : u64;
}

temp_arena_memory_begin :: (arena: *Arena) -> Temp_Arena_Memory
{
    temp : Temp_Arena_Memory;
    temp.arena = arena;
    temp.previous_offset = arena.previous_offset;
    temp.current_offset = arena.current_offset;
    return temp;
}

temp_arena_memory_end :: (temp: Temp_Arena_Memory)
{
    temp.arena.previous_offset = temp.previous_offset;
    temp.arena.current_offset = temp.current_offset;
}

arena_alloc_align :: (arena: *Arena, size: u64, align: u64) -> *void
{
    // Align
    curr_ptr : *u64 = (:*u64)arena.buf + (:*u64)arena.current_offset;
    offset : *u64 = align_forward(curr_ptr, align);
    offset -= (:*u64)arena.buf;

    if (offset + size <= arena.buf_length)
    {
        ptr : *void = (:*void)(*(arena.buf[(:u64)offset]));
        arena.previous_offset = offset;
        arena.current_offset = offset + size;

        _c.memset(ptr, 0, size);
        return ptr;
    }

    return null;
}

DEFAULT_ALIGNMENT :: 2 * sizeof(*void);

arena_alloc :: (arena: *Arena, size: u64) -> *void
{
    return arena_alloc_align(arena, size, DEFAULT_ALIGNMENT);
}

arena_resize_align :: (arena: *Arena, old_memory: *void, old_size: u64, new_size: u64, align: u64) -> *void
{
    old_mem: *u8 = (:*u8)old_memory;

    assert(is_power_of_two(align));

    if (old_mem == null || old_size == 0)
    {
        return arena_alloc_align(arena, new_size, align);
    }
    else if (arena.buf <= old_mem && old_mem < arena.buf + arena.buf_length)
    {
        if (arena.buf + arena.previous_offset == old_mem)
        {
            arena.current_offset = arena.previous_offset + new_size;
            if (new_size > old_size)
            {
                _c.memset(*(arena.buf[arena.current_offset]), 0, new_size - old_size);
            }
            return old_memory;
        }
        else
        {
            new_memory : *void = arena_alloc_align(arena, new_size, align);
            copy_size := old_size;
            if (old_size < new_size)
            {
                copy_size = old_size;
            }
            else
            {
                copy_size = new_size;
            }
            _c.memmove(new_memory, old_memory, copy_size);
            return new_memory;
        }
    }
    else
    {
        assert(false); // Memory out of arena bounds
        return null;
    }
}

arena_resize :: (arena: *Arena, old_memory: *void, old_size: u64, new_size: u64) -> *void
{
    return arena_resize_align(arena, old_memory, old_size, new_size, DEFAULT_ALIGNMENT);
}

arena_free_all :: (arena: *Arena)
{
    arena.current_offset = 0;
    arena.current_offset = 0;
}

Stack_Allocator :: struct
{
    buf             : *u8;
    buf_length      : u64;
    previous_offset : u64;
    current_offset  : u64;
}

Stack_Allocation_Header :: struct
{
    previous_offset : u64;
    padding         : u64;
}

stack_allocator_init :: (stack: *Stack_Allocator, buffer: *void, buffer_length: u64)
{
    stack.buf = (:*u8)buffer;
    stack.buf_length = buffer_length;
    stack.current_offset = 0;
}

calc_padding_with_header :: (ptr: *u64, alignment: u64, header_size: u64) -> u64
{
    p : *u64;
    a : *u64;
    modulo : *u64;
    padding : *u64;
    needed_space : *u64;

    assert(is_power_of_two(alignment));

    p = ptr;
    a = (:*u64)alignment;
    modulo = p & (a - 1);

    padding = (:*u64)0;
    needed_space = (:*u64)0;

    if (modulo != 0)
    {
        padding = a - modulo;
    }

    needed_space = (:*u64)header_size;

    if (padding < needed_space)
    {
        needed_space -= padding;

        if ((needed_space & (a - 1)) != 0)
        {
            padding += a * (1 + (needed_space / a));
        }
        else
        {
            padding += a * (needed_space / a);
        }
    }

    return (:u64)padding;
}

stack_alloc_align :: (stack: *Stack_Allocator, size: u64, alignment: u64) -> *void
{
    curr_addr: *u64;
    next_addr: *u64;
    padding: u64;
    header: *Stack_Allocation_Header;

    assert(is_power_of_two(alignment));

    if (alignment > 128)
    {
        alignment = 128;
    }

    curr_addr = (:*u64)stack.buf + (:*u64)stack.current_offset;
    padding = calc_padding_with_header(curr_addr, alignment, sizeof(Stack_Allocation_Header));
    if (stack.current_offset + padding + size > stack.buf_length)
    {
        assert(false);
        return null;
    }

    stack.previous_offset = stack.current_offset;
    stack.current_offset += padding;

    next_addr = curr_addr + (:*u64)padding;
    header = (:*Stack_Allocation_Header)(next_addr - sizeof(Stack_Allocation_Header));
    header.padding = padding;
    header.previous_offset = stack.previous_offset;

    stack.current_offset += size;

    return _c.memset((:*void)next_addr, 0, size);
}

stack_alloc :: (stack: *Stack_Allocator, size: u64) -> *void
{
    return stack_alloc_align(stack, size, DEFAULT_ALIGNMENT);
}

stack_free :: (stack: *Stack_Allocator, ptr: *void)
{
    if (ptr != null)
    {
        start: *u64;
        end: *u64;
        curr_addr: *u64;
        header: *Stack_Allocation_Header;
        prev_offset: u64;

        start = (:*u64)stack.buf;
        end = start + (:*u64)stack.buf_length;
        curr_addr = (:*u64)ptr;

        if (!(start <= curr_addr && curr_addr < end))
        {
            assert(false); // Pointer out of bounds of stack allocator
            return;
        }

        if (curr_addr >= start + (:*u64)stack.current_offset)
        {
            // Allow double free
            return;
        }

        header = (:*Stack_Allocation_Header)(curr_addr - sizeof(Stack_Allocation_Header));
        prev_offset = (:u64)(curr_addr - (:*u64)header.padding - start);

        stack.current_offset = prev_offset;
    }
}

stack_resize_align :: (stack: *Stack_Allocator, ptr: *void, old_size: u64, new_size: u64,
                       alignment: u64)
{
    assert(false); // Not implemented
}

stack_resize :: (stack: *Stack_Allocator, ptr: *void, old_size: u64, new_size: u64) -> *void
{
    return stack_resize_align(stack, ptr, old_size, new_size, DEFAULT_ALIGNMENT);
}

stack_free_all :: (stack: *Stack_Allocator)
{
    stack.current_offset = 0;
}

String :: struct
{
    data   : *u8;
    length : u64;

    #overload[] string_index;
}

string_length :: (c_str: *u8) -> u64
{
    length : u64 = 0;
    i : u64 = 0;

    while (c_str[i] != 0)
    {
        i += 1;
        length += 1;
    }

    return length;
}

string_index :: (str: String, index: u64) -> u8
{
    assert(index < str.length);

    return str.data[index];
}

string_index :: (str: *String, index: u64) -> u8
{
    return string_index(<str, index);
}

print :: (str: String)
{
    _c.printf("%.*s\n", str.length, str.data);
}

print :: (num: u64)
{
    _buf: [32]u8;
    buf := *_buf[0];
    length := _c.sprintf(buf, "%llu", num);
    print({ buf, (:u64)length });
}

print :: (num: int)
{
    _buf: [32]u8;
    buf := *_buf[0];
    length := _c.sprintf(buf, "%lld", num);
    print({ buf, (:u64)length });
}

Array :: struct(T)
{
    data     : *T;
    count    : u64;
    capacity : u64;

    #overload[] array_index;
}

array_add :: (array: *Array($T), element: T)
{
    assert(array);

    if (array.count >= array.capacity)
    {
        new_cap := array.capacity * 2;
        if (new_cap < 8) new_cap = 8;
        array_grow(array, new_cap);
    }

    assert(array.data);

    array.data[array.count] = element;
    array.count += 1;
}

array_index :: (array: Array($T), index: u64) -> T
{
    if (index < array.count)
    {
        return array.data[index];
    }

    assert(false);
}

array_index :: (array: *Array($T), index: u64) -> T
{
    return array_index(<array, index);
}

array_grow :: (array: *Array($T), new_cap: u64)
{
    assert(array);
    assert(new_cap > array.capacity);

    new_data := _c.malloc(sizeof(T) * new_cap);
    assert(new_data);

    if (array.data)
    {
        assert(array.capacity);
        _c.memcpy(new_data, array.data, array.capacity * sizeof(T));
        _c.free(array.data);
    }
    else
    {
        assert(array.capacity == 0);
        assert(array.count == 0);
    }

    array.data = new_data;
    array.capacity = new_cap;
}

array_free :: (array: *Array($T))
{
    assert(array);
    if (array.data)
    {
        _c.free(array.data);
        array.data = null;
        array.count = 0;
        array.capacity = 0;
    }
}
