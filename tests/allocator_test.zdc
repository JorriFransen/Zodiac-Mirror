
_c :: import c;

std :: import std;

c_allocator :: import c_allocator;

_printer :: import print;
using _printer;

main :: ()
{
    _builtin_open_std_handles();

    ca := c_allocator.get();

    ptr, err := alloc(ca, sizeof(int) * 5, sizeof(int));
    assert(ptr);
    assert(err == Allocation_Error.NONE);
    defer _free(ca, ptr, 0);

    int_ptr := (:*int)ptr;
    for (i := 0; i < 5; i++)
    {
        int_ptr[i] = (i + 1) * 3;
    }

    ptr1, err1 := alloc(ca, 1024, 0);
    ptr2, err2 := alloc(ca, 4096 * 3, 0);
    ptr3, err3 := alloc(ca, 4096, 0);

    _free(ca, ptr1, 0);

    for (i := 0; i < 5; i++)
    {
        print("int_ptr[%] = %\n", i, int_ptr[i]);
    }

    _free(ca, ptr2, 0);
    _free(ca, ptr3, 0);

    print("sizeof(Message): %\n", sizeof(Message));

    message_test(ca);

    temp_test();

    return 0;
}

temp_allocator :: import temp_allocator;

temp_test :: ()
{
    ta := temp_allocator.create(128, false, false);

    for (i := 0; i < 128; i++)
    {
        alloc_type(ta, u8);
    }

    temp_allocator.clear((:*temp_allocator.Temp_Allocator)ta);

    for (i := 0; i < 128; i++)
    {
        alloc_type(ta, u8);
    }

    // alloc_type(ta, u8);
}

message_test :: (allocator: *Allocator)
{
    m0 := message_create(allocator, 0, "First message");
    defer _free(allocator, m0, 0);

    message_print(m0);
}

Message :: struct
{
    id        : u64;
    sender_id : u64;
    message   : String;
}

__next_message_id : u64 = 0;

message_create :: (ca: *Allocator, sender_id: u64, str: String) -> *Message
{
    result, err := alloc_type(ca, Message);
    assert(err == Allocation_Error.NONE);

    result.id = __next_message_id;
    __next_message_id += 1;

    result.sender_id = sender_id;

    result.message = std.string_create(ca, str);

    return result;
}

message_print :: (msg: *Message)
{
    print("%: (from: %): '%'\n", msg.id, msg.sender_id, msg.message.data);
}
