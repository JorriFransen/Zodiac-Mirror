
_c :: import c;

Thread :: struct
{
    handle: u64;
    user_data: *void;
}

Thread_Routine :: typedef *(thread: *Thread) -> *void;

create_thread :: (thread_routine: Thread_Routine, user_data: *void) -> Thread
{
     return __create_thread__(thread_routine, user_data);
}

create_thread :: (thread_routine: Thread_Routine, user_data: $T) -> Thread
{
    return __create_thread__(thread_routine, (:*void)user_data);
}

join_thread :: (thread: Thread) -> *void
{
    return __join_thread__(thread);
}

compare_and_swap :: (pointer: *u64, old_value: u64, new_value: u64) -> bool
{
    return __compare_and_swap__(pointer, old_value, new_value);
}

Mutex :: struct
{
    lock: u64;
}

mutex_init :: (mutex: *Mutex)
{
    mutex.lock = 0;
}

mutex_lock :: (mutex: *Mutex)
{
    while (!compare_and_swap(*mutex.lock, 0, 1))
    {
        // busy wait
    }
}

mutex_unlock :: (mutex: *Mutex)
{
    mutex.lock = 0;
}

Atomic_Cond :: struct
{
    sig       : u64;
    broadcast : u64;
}

atomic_cond_init :: (signal: *Atomic_Cond)
{
    signal.sig = 0;
    signal.broadcast = 0;
}

atomic_cond_wait :: (signal: *Atomic_Cond, mutex: *Mutex)
{
    mutex_unlock(mutex);

    while (!compare_and_swap(*signal.sig, 1, 0))
    {
        if (signal.broadcast)
        {
            break;
        }
    }

    mutex_lock(mutex);
}

atomic_cond_signal :: (signal: *Atomic_Cond)
{
    while (!compare_and_swap(*signal.sig, 0, 1))
    {
        // Busy wait
    }
}

atomic_cond_broadcast :: (signal: *Atomic_Cond)
{
    signal.broadcast = 1;
}

// This is a weak semaphore
Semaphore :: struct
{
    count : int;
    lock  : Mutex;
    wait  : Atomic_Cond;
}

semaphore_init :: (sem: *Semaphore, count: int)
{
    sem.count = count;
    mutex_init(*sem.lock);
    atomic_cond_init(*sem.wait);
}

semaphore_wait :: (sem: *Semaphore)
{
    mutex_lock(*sem.lock);
    sem.count -= 1;

    if (sem.count < 0)
    {
        atomic_cond_wait(*sem.wait, *sem.lock);
    }

    mutex_unlock(*sem.lock);
}

semaphore_signal :: (sem: *Semaphore)
{
    mutex_lock(*sem.lock);
    old_count := sem.count;
    sem.count += 1;
    mutex_unlock(*sem.lock);

    if (old_count < 0)
    {
        atomic_cond_signal(*sem.wait);
    }
}

_main :: ()
{
    printer_args := (:*void)6;

    t0 : Thread;
    t0.user_data = (:*void)5;

    printer(*t0);

    t1 := create_thread(*printer, printer_args);
    t2 := create_thread(*printer, t0.user_data);


    _c.printf("t1.handle: %d\n", t1.handle);
    _c.printf("t2.handle: %d\n", t2.handle);

    join_thread(t1);
    join_thread(t2);

    t3 := create_thread(*printer, (:*void)3);
    _c.printf("t3.handle: %d\n", t3.handle);

    join_thread(t3);
}

printer :: (thread: *Thread) -> *void
{
    // _c.printf("thread: %p\n", thread);
    count := (:u64)thread.user_data;
    _c.printf("starting printer, handle=%d, data=%ld\n", thread.handle, count);

    // _c.getchar();

    while (count > 0)
    {
        _c.printf("Printer %d: %d\n", thread.handle, count);
        count--;
    }
}
