
_c :: import c;
using _c;

_printer :: import print;
using _printer;

posix :: import posix;

os_linux :: import os_linux;
using os_linux;

string_builder :: import string_builder;

main :: ()
{
    open_std_handles();

    print("Subprocess test\n");

    err, res := execute_process("./tp", "");
    assert(err == Execute_Process_Error.NONE);
    _c.printf("execute_process returned: %d\n", res.exit_code);
    assert(res.exit_code == 7);

    print("\nstdout: \n%\n", res.stdout.data);
    print("stderr: \n%\n", res.stderr.data);

    // err, res = execute_process("ls", "-la");
    // assert(err == Execute_Process_Error.NONE);
    // _c.printf("execute_process returned: %d\n", res.exit_code);

    return 0;
}

Execute_Process_Error :: enum
{
    NONE;
    PIPE_CREATE_FAILED;
    FORK_FAILED;
    UNEXPECTED;
}

Execute_Process_Result :: struct
{
    exit_code : u32;
    stdout    : String;
    stderr    : String;
}

execute_process :: (command: String, args: ...) ->
    Execute_Process_Error #required,
    Execute_Process_Result
{
    pipe_err : IO_Error;
    in       : Pipe;
    out      : Pipe;
    err      : Pipe;

    using Execute_Process_Error;

    result : Execute_Process_Result;
    result.exit_code = 0;
    result.stdout = { null, 0 };

    pipe_err, in = pipe_create();
    if (pipe_err != IO_Error.NONE) return PIPE_CREATE_FAILED, result;
    defer pipe_close(*in);

    pipe_err, out = pipe_create();
    if (pipe_err != IO_Error.NONE) return PIPE_CREATE_FAILED, result;
    defer pipe_close(*out);

    pipe_err, err = pipe_create();
    if (pipe_err != IO_Error.NONE) return PIPE_CREATE_FAILED, result;
    defer pipe_close(*err);

    pid := posix.fork();

    if (pid == 0)
    {
        _args : std.Array(*u8) = { null, 0, 0 };
        defer std.array_free(*_args);

        std.array_add(*_args, "sh");
        std.array_add(*_args, "-c");
        std.array_add(*_args, command.data);
        for (i := 0; i < args.count; i++)
        {
            arg_any := args[i];
            assert(arg_any.type_info == get_type_info(*u8));
            arg_val := <((:**u8)arg_any.value)
            std.array_add(*_args, arg_val);
        }
        std.array_add(*_args, null);

        pipe_close_write(*in);
        pipe_close_read(*out);
        pipe_close_read(*err);

        posix.dup2(in.read_fd, posix.STDIN_FILENO);
        posix.dup2(out.write_fd, posix.STDOUT_FILENO);
        posix.dup2(err.write_fd, posix.STDERR_FILENO);

        pipe_close_read(*in);
        pipe_close_write(*out);
        pipe_close_write(*err);

        exec_res := posix.execv("/bin/sh", _args.data);

        if (exec_res == -1)
        {
            _c.fprintf(stderr, "Command execution failed: \"sh -c %s\"\n", command.data);
            assert(false);
        }

        posix._exit(1);
    }
    else if (pid > 0)
    {
        pipe_close_read(*in);
        pipe_close_write(*out);
        pipe_close_write(*err);

        buf : [1024]u8;
        readc : s32;

        status : u32 = 0;
        wait_res := posix.wait(*status);
        assert(wait_res == pid);
        assert(posix.WIFEXITED(status));

        result.exit_code = posix.WEXITSTATUS(status);

        str_builder : string_builder.String_Builder;
        string_builder.init(*str_builder, (:u64)array_length(buf));
        defer string_builder.free(*str_builder);

        reading := true;
        while (reading)
        {
            readc = posix.read(out.read_fd, *buf, (:s32)array_length(buf));
            assert(readc >= 0);
            if (readc) string_builder.append(*str_builder, (:*u8)(*buf), (:s64)readc);
            else reading = false;
        }

        result.stdout = string_builder.copy_to_string(*str_builder);
        string_builder.reset(*str_builder);

        reading = true;
        while (reading)
        {
            readc = posix.read(err.read_fd, *buf, (:s32)array_length(buf));
            assert(readc >= 0);
            if (readc) string_builder.append(*str_builder, (:*u8)(*buf), (:s64)readc);
            else reading = false;
        }

        result.stderr = string_builder.copy_to_string(*str_builder);

        return NONE, result;
    }
    else
    {
        assert(false);
        return FORK_FAILED, result;
    }

    assert(false);
    return UNEXPECTED, result;
}
