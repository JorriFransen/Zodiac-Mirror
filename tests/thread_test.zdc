
std :: import std;
using std;

// _c :: import c;
using _c;

_thread :: import thread;
using _thread;

global_counter : u64 = 0;
global_counter_2 : u64 = 0;

global_counter_2_mutex : Mutex;

main :: ()
{
    open_std_handles();

    _main();

    std.print("\nthread test");
    printf("global_counter: %llu\n", global_counter);

    adders : std.Array(Thread);

    adder_count := 1000;
    amount_per_adder := 10;

    for (i := 0; i < adder_count; i++)
    {
        at : Thread;
        if (i % 2)
        {
            at = create_thread(*add_func, amount_per_adder);
        }
        else
        {
            at = create_thread(*add_func2, amount_per_adder);
        }

        if (at.handle)
        {
            array_add(*adders, at);
        }
        else
        {
            fprintf(stderr, "Thread creation failed!\n");
            adder_count = i;
            break;
        }

        // if (i % 1000 == 0)
        // {
            // std.print("\t1000 threads created for pool 1");
            // _c.printf("\t\tglobal_counter: %lu\n", global_counter);
        // }

    }


    std.print("All threads for pool 1 created");

    all_returns : u64 = 0;

    for (i : u64 = 0; i < adders.count; i++)
    {
        at := adders[i];
        all_returns += (:u64)join_thread(at);
    }

    printf("global_counter: %llu\n", global_counter);
    printf("\texpected: %llu\n", (:u64)(adder_count * amount_per_adder));
    assert(global_counter == (:u64)(adder_count * amount_per_adder));
    printf("\tall_returns: %lu\n\n", all_returns);

    adders.count = 0;

    for (i := 0; i < adder_count; i++)
    {
        at : Thread;
        if (i % 2)
        {
            at = create_thread(*add_func_mut, amount_per_adder);
        }
        else
        {
            at = create_thread(*add_func_mut2, amount_per_adder);
        }

        if (at.handle)
        {
            array_add(*adders, at);
        }
        else
        {
            fprintf(stderr, "Thread creation failed\n");
            adder_count = i;
            break;
        }
    }

    std.print("All threads for pool 2 created");

    all_returns_2 : u64 = 0;

    for (i : u64 = 0; i < adders.count; i++)
    {
        at := adders[i];
        all_returns_2 += (:u64)join_thread(at);
    }

    printf("global_counter_2: %llu\n", global_counter_2);
    printf("\texpected: %llu\n", (:u64)(adder_count * amount_per_adder));
    assert(global_counter_2 == (:u64)(adder_count * amount_per_adder));
    printf("\tall_returns_2: %lu\n\n", all_returns_2);

    array_free(*adders);

    semaphore_test();
}

SEM_BUFFER_CAP     : u64 : 8;
SEM_BUFFER_COUNT   : u64 : 1;
SEM_PRODUCER_COUNT : u64 : 1;
SEM_CONSUMER_COUNT : u64 : 1;

sem_lock      : Semaphore;
sem_buf_full  : Semaphore;
sem_buf_empty : Semaphore;

pc_done : u64 = 0;

PC_Data :: struct
{
    empty_buffers : Queue(*u64);
    full_buffers  : Queue(*u64);
}

semaphore_test :: ()
{
    std.print(" ");
    std.print("Semaphore test");

    semaphore_init(*sem_lock, 1);
    semaphore_init(*sem_buf_full, 0);
    semaphore_init(*sem_buf_empty, (:int)SEM_BUFFER_COUNT);

    pc_data : PC_Data;
    queue_init(*pc_data.empty_buffers, SEM_BUFFER_COUNT);
    queue_init(*pc_data.full_buffers, SEM_BUFFER_COUNT);

    empty_buffers : Queue(*u64);
    queue_init(*empty_buffers, SEM_BUFFER_COUNT);

    for (i : u64 = 0; i < SEM_BUFFER_COUNT; i++)
    {
        buffer := (:*u64)_c.malloc(SEM_BUFFER_CAP * sizeof(u64));
        _c.printf("Allocated_buffer: %p\n", buffer);
        queue_enqueue(*pc_data.empty_buffers, buffer);
    }

    pt := create_thread(*produce, (:*void)(*pc_data));
    ct := create_thread(*consume, (:*void)(*pc_data));

    _c.getchar();
    assert(pc_done == 0);
    while (!compare_and_swap(*pc_done, 0, 1)) {}
    join_thread(pt);
    join_thread(ct);
}

produce :: (thread: *Thread) -> *void
{
    while (!compare_and_swap(*pc_done, 1, 1))
    {
        semaphore_wait(*sem_buf_empty);

        semaphore_wait(*sem_lock);
        pc_data := (:*PC_Data)thread.user_data;
        buffer := queue_dequeue(*pc_data.empty_buffers);
        _c.printf("Producing in buffer: %p\n", buffer);
        semaphore_signal(*sem_lock);

        for (i : u64 = 0; i < SEM_BUFFER_CAP; i++)
        {
            buffer[i] = i * i;
            _c.usleep(1000 * 500);
        }

        semaphore_wait(*sem_lock);
        queue_enqueue(*pc_data.full_buffers, buffer);
        semaphore_signal(*sem_lock);

        semaphore_signal(*sem_buf_full);
    }
}

consume :: (thread: *Thread) -> *void
{
    while (!compare_and_swap(*pc_done, 1, 1))
    {
        semaphore_wait(*sem_buf_full);
        _c.printf("-- waited full\n");

        semaphore_wait(*sem_lock);
        pc_data := (:*PC_Data)thread.user_data;
        buffer := queue_dequeue(*pc_data.full_buffers);
        semaphore_signal(*sem_lock);

        std.print("=========================================");
        _c.printf("\tConsuming from buffer: %p\n", buffer);
        for (i : u64 = 0; i < SEM_BUFFER_CAP; i++)
        {
            _c.printf("buffer[%lu]: %lu\n", i, buffer[i]);
        }
        std.print("=========================================\n");

        semaphore_wait(*sem_lock);
        queue_enqueue(*pc_data.empty_buffers, buffer);
        semaphore_signal(*sem_lock);

        semaphore_signal(*sem_buf_empty);
    }
}

add_func_mut :: (thread: *Thread) -> *void
{
    to_add := (:u64)thread.user_data;
    mutex_lock(*global_counter_2_mutex);
    for (i : u64 = 0; i < to_add; i++)
    {
        global_counter_2 += 1;
    }
    mutex_unlock(*global_counter_2_mutex);

    return to_add;
}

add_func_mut2 :: (thread: *Thread) -> *void
{
    to_add := (:u64)thread.user_data;
    mutex_lock(*global_counter_2_mutex);
    global_counter_2 += to_add;
    mutex_unlock(*global_counter_2_mutex);

    return to_add;
}

add_func :: (thread: *Thread) -> *void
{
    to_add := (:u64)thread.user_data;

    for (i : u64 = 0; i < to_add; i++)
    {
        done := false;
        while (!done)
        {
            value := global_counter;
            done = compare_and_swap(*global_counter, value, value + 1);
        }
    }

    return to_add;
}

add_func2 :: (thread: *Thread) -> *void
{
    to_add := (:u64)thread.user_data;

    done := false;
    while (!done)
    {
        value := global_counter;
        done = compare_and_swap(*global_counter, value, value + to_add);
    }

    return to_add;
}
