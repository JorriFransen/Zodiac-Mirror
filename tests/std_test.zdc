//
//    overloading poly functions
//    operator overloading
//    asserts
//

std :: import std;
using std;

add :: (a: $T, b: T) -> T
{
    return a + b;
}

main :: ()
{
    // assert(false);

    _c.printf("add(1, 2): %d\n", add(1, 2));
    _c.printf("add(4, 8): %d\n", add(4, 8));
    _c.printf("add(1.2, 3.4): %f\n", add(1.2, 3.4));

    print(" ");

    c_string := "This is a test string";
    print(std.string_length("abc"));
    test_str : String = { c_string, _c.strlen(c_string) };

    _c.printf("test_str.length: %llu\n", test_str.length);
    _c.printf("test_str[2]: %c\n", test_str[2]);

    // test_str_ptr := *test_str;
    // tsp2 := test_str_ptr[2];

    print(test_str);

    print({ "This should work as well", 5 });
    print("This should work as well");
    print(c_string);

    print(" ");

    int_array : Array(int);
    float_array : Array(float);
    int_array2 : Array(int);

    for (i : u64 = 0; i < 5; i = i + 1)
    {
        j := i + 1;
        array_add(*int_array, (:int)(j * j));
        array_add(*int_array2, (:int)(j + j));
        array_add(*float_array, j * j / 3.0);
    }

    for (i : u64 = 0; i < int_array.count; i = i + 1)
    {
        _c.printf("int_array[%d]: %d\n", i, int_array.data[i]);
        array_add(*int_array2, array_index(int_array, i));
    }

    print(" ");

    for (i : u64 = 0; i < float_array.count; i = i + 1)
    {
        _c.printf("float_array[%d]: %f\n", i, float_array.data[i]);
        array_add(*int_array2, (:int)float_array.data[i]);
    }

    print(" ");

    for (i : u64 = 0; i < int_array2.count; i = i + 1)
    {
        _c.printf("int_array2[%d]: %d\n", i, int_array2[i]);

    }

    array_free(*int_array);
    array_free(*int_array2);
    array_free(*float_array);
}

