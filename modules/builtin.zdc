
int :: typedef s64;

FILE :: typedef *void;

stdin  : *FILE = null;
stdout : *FILE = null;
stderr : *FILE = null;

#foreign fdopen :: (fd: int, mode: *u8) -> *FILE;
#foreign fprintf :: (file: *FILE, format: *u8, ...) -> int;
#foreign exit :: (status: s32) -> void;

open_std_handles :: () -> void
{
    stdin = fdopen(0, "r");
    stdout = fdopen(1, "w");
    stderr = fdopen(2, "w");
}

static_if (PLATFORM_WINDOWS)
{
    print_stack_trace :: ()
    {
    }
}
else static_if(PLATFORM_LINUX)
{
    #foreign backtrace :: (buffer: **void, size: int) -> int;
    #foreign backtrace_symbols :: (buffer: **void, size: int) -> **u8;

    print_stack_trace :: ()
    {
        MAX_STACK_TRACE_LENGTH :: 1024;
        frames : [MAX_STACK_TRACE_LENGTH]*void;
        trace_length := backtrace(*frames[0], MAX_STACK_TRACE_LENGTH);

        names := backtrace_symbols(*frames[0], trace_length);
        for (i := 0; i < trace_length; i++)
        {
            fprintf(stderr, "%s:\n", names[i]);
        }
    }
}
else
{
    static_assert(false);
}

default_assert_handler :: (value: bool, function_name: *u8, file_name: *u8, line: s64)
{
    if (value)
    {
        return;
    }

    if (stderr)
    {
        open_std_handles();
    }

    // _c.fprintf(_c._stderr, "\n\n");
    fprintf(stderr, "Assertion failed in function %s : %s:%d\n", function_name,
                file_name, line);

    static_if (ZODIAC_RUNNING_BYTECODE)
    {
        __assert_fail();
    }
    else
    {
        print_stack_trace();
        exit(-1);
        // nptr : *int = null;
        // <nptr = 1;
    }
}

Context :: struct
{
    
}
