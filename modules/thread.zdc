
_c :: import c;
pthread :: import pthread;

int :: typedef s64;

Thread :: struct
{
    handle: u64;
    user_data: *void;
}

Thread_Routine :: typedef *(thread: *Thread) -> *void;

Thread_Start_Info :: struct
{
    thread: Thread;
    thread_routine: Thread_Routine;
    signal_started: Atomic_Cond;
    signal_thread_copied: Atomic_Cond;
}

create_thread :: (thread_routine: Thread_Routine, user_data: *void) -> Thread
{
    static_if (ZODIAC_RUNNING_BYTECODE)
    {
        return __create_thread__(thread_routine, user_data);
    }
    else
    {
        start_info : Thread_Start_Info;
        start_info.thread.user_data = user_data;
        atomic_cond_init(*start_info.signal_started);
        atomic_cond_init(*start_info.signal_thread_copied);
        start_info.thread_routine = thread_routine;
        thread_ptr := *start_info.thread;

        success := pthread.pthread_create((:*pthread.pthread_t)(*thread_ptr.handle), null,
                                        *__zodiac_start_thread, *start_info);
        assert(success == 0);
        atomic_cond_signal(*start_info.signal_started);
        atomic_cond_wait(*start_info.signal_thread_copied, null);

        result := start_info.thread;
        return result;
    }
}

__zodiac_start_thread :: (_thread_start_info: *void) -> *void
{
    thread_start_info := (:*Thread_Start_Info)_thread_start_info;

    atomic_cond_wait(*thread_start_info.signal_started, null);
    thread_func := thread_start_info.thread_routine;
    thread := thread_start_info.thread;
    atomic_cond_signal(*thread_start_info.signal_thread_copied);

    // return null;
    ret_val := thread_func(*thread);
    return ret_val;
}

create_thread :: (thread_routine: Thread_Routine, user_data: $T) -> Thread
{
    return create_thread(thread_routine, (:*void)user_data);
}

join_thread :: (thread: Thread) -> *void
{
    static_if (ZODIAC_RUNNING_BYTECODE)
    {
        return __join_thread__(thread);
    }
    else
    {
        ret_val : *void = null;
        success := pthread.pthread_join((:pthread.pthread_t)thread.handle, *ret_val);
        assert(success == 0);
        return ret_val;
    }
}

compare_and_swap :: (pointer: *u64, old_value: u64, new_value: u64) -> bool
{
    return __compare_and_swap__(pointer, old_value, new_value);
}

compare_and_swap :: (pointer: *$T, old_value: T, new_value: T) -> bool
{
    return __compare_and_swap__((:*u64)pointer, (:u64)old_value, (:u64)new_value);
}

Mutex :: struct
{
    lock: u64;
}

mutex_init :: (mutex: *Mutex)
{
    mutex.lock = 0;
}

mutex_lock :: (mutex: *Mutex)
{
    while (!compare_and_swap(*mutex.lock, 0, 1))
    {
        // busy wait
    }
}

mutex_unlock :: (mutex: *Mutex)
{
    mutex.lock = 0;
}

Atomic_Cond :: struct
{
    sig       : u64;
    broadcast : u64;
}

atomic_cond_init :: (signal: *Atomic_Cond)
{
    signal.sig = 0;
    signal.broadcast = 0;
}

atomic_cond_wait :: (signal: *Atomic_Cond, mutex: *Mutex)
{
    if (mutex) mutex_unlock(mutex);

    while (!compare_and_swap(*signal.sig, 1, 0))
    {
        if (signal.broadcast)
        {
            break;
        }
    }

    if (mutex) mutex_lock(mutex);
}

atomic_cond_signal :: (signal: *Atomic_Cond)
{
    while (!compare_and_swap(*signal.sig, 0, 1))
    {
        // Busy wait
    }
}

atomic_cond_broadcast :: (signal: *Atomic_Cond)
{
    signal.broadcast = 1;
}

// This is a weak semaphore
Semaphore :: struct
{
    count : int;
    lock  : Mutex;
    wait  : Atomic_Cond;
}

semaphore_init :: (sem: *Semaphore, count: int)
{
    sem.count = count;
    mutex_init(*sem.lock);
    atomic_cond_init(*sem.wait);
}

semaphore_wait :: (sem: *Semaphore)
{
    mutex_lock(*sem.lock);
    sem.count -= 1;

    if (sem.count < 0)
    {
        atomic_cond_wait(*sem.wait, *sem.lock);
    }

    mutex_unlock(*sem.lock);
}

semaphore_signal :: (sem: *Semaphore)
{
    mutex_lock(*sem.lock);
    old_count := sem.count;
    sem.count += 1;
    mutex_unlock(*sem.lock);

    if (old_count < 0)
    {
        atomic_cond_signal(*sem.wait);
    }
}

_main :: ()
{
    printer_args := (:*void)6;

    t0 : Thread;
    t0.user_data = (:*void)5;
    t0.handle = 12345;

    printer(*t0);

    t1 := create_thread(*printer, printer_args);
    t2 := create_thread(*printer, t0.user_data);

    _c.printf("t1.handle: %d\n", t1.handle);
    _c.printf("t2.handle: %d\n", t2.handle);

    join_thread(t1);
    join_thread(t2);

    t3 := create_thread(*printer, (:*void)3);
    _c.printf("t3.handle: %d\n", t3.handle);

    join_thread(t3);
}

printer :: (thread: *Thread) -> *void
{
    count := (:u64)thread.user_data;
    _c.printf("starting printer, handle=%d, data=%ld\n", thread.handle, count);

    // _c.getchar();

    while (count > 0)
    {
        _c.printf("Printer %d: %d\n", thread.handle, count);
        count--;
    }
}
